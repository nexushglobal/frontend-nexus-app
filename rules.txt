# ğŸ“‹ GuÃ­a de Arquitectura y Patrones de Archivos - Next.js Feature-based

## ğŸ¯ Estructura Base del Proyecto

```
src/
â”œâ”€â”€ app/                    # App Router - Solo routing y metadata
â”œâ”€â”€ features/               # Feature-based organization  
â”œâ”€â”€ components/             # shadcn/ui components
â”œâ”€â”€ lib/                    # Configuraciones globales
â”œâ”€â”€ types/                  # Declaraciones globales
â””â”€â”€ styles/                 # Estilos globales
```

## ğŸŒ API WRAPPER CENTRALIZADO

### **ConfiguraciÃ³n obligatoria:**

**API Response estÃ¡ndar del backend:**
```typescript
// features/shared/types/api.types.ts
export interface ApiResponse<T = any> {
  success: boolean
  data: T | null
  message: string | string[]
  errors: string | string[] | null
}

export class ApiError extends Error {
  public success: boolean
  public errors: string | string[] | null
  public statusCode: number
}
```

**Wrapper centralizado:**
```typescript
// features/shared/services/api.ts
import { env } from '@/lib/env'

class ApiClient {
  async call<T>(endpoint: string, options: ApiOptions = {}): Promise<T> {
    const response = await fetch(`${env.apiUrl}${endpoint}`, options)
    const result: ApiResponse<T> = await response.json()
    
    if (!result.success) {
      throw new ApiError(result.message, result.errors, response.status)
    }
    
    return result.data as T // Solo retorna la data
  }
  
  async get<T>(endpoint: string, options = {}): Promise<T> {
    return this.call<T>(endpoint, { ...options, method: 'GET' })
  }
  
  async post<T>(endpoint: string, data?: any, options = {}): Promise<T> {
    return this.call<T>(endpoint, {
      ...options,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    })
  }
}

export const api = new ApiClient()

// Para Server Components con optimizaciones Next.js
export const serverApi = {
  static: <T>(endpoint: string) => api.get<T>(endpoint, { cache: 'force-cache' }),
  revalidate: <T>(endpoint: string, seconds: number) => 
    api.get<T>(endpoint, { next: { revalidate: seconds } }),
  fresh: <T>(endpoint: string) => api.get<T>(endpoint, { cache: 'no-store' }),
}
```

### **Uso en Actions vs Services:**

**En Server Actions:**
```typescript
'use server'
import { api } from '@/features/shared/services/api'

export async function createSaleAction(formData: FormData) {
  // ValidaciÃ³n server-side obligatoria
  const title = formData.get('title') as string
  if (!title) return { success: false, error: 'Title required' }
  
  try {
    // api.post() ya maneja la estructura ApiResponse<T>
    const response = await api.post<{message: string}>('/sales', { title })
    
    return {
      success: true,
      message: response.message // response solo contiene la data
    }
  } catch (error) {
    if (error instanceof ApiError) {
      return { success: false, error: error.message, errors: error.errors }
    }
    return { success: false, error: 'Error interno' }
  }
}
```

**En Services (Client):**
```typescript
import { api } from '@/features/shared/services/api'

export class SalesService {
  static async getSales(): Promise<Sale[]> {
    return api.get<Sale[]>('/sales') // Ya maneja ApiResponse automÃ¡ticamente
  }
}
```

**En Server Components:**
```typescript
export default async function Page() {
  try {
    const users = await serverApi.revalidate<User[]>('/users', 300) // 5 min cache
    return <UsersList users={users} />
  } catch (error) {
    return <ErrorPage error={error} />
  }
}
```

## ğŸ“ REGLAS DE ESTRUCTURA DE CARPETAS

### 1. **APP ROUTER** (`src/app/`)
**PropÃ³sito:** Solo routing, layouts y metadata. NO lÃ³gica de negocio.

**Estructura:**
```
app/
â”œâ”€â”€ (auth)/                 # Route groups
â”œâ”€â”€ (dashboard)/            
â”œâ”€â”€ (admin)/
â”œâ”€â”€ api/                    # API Routes
â”œâ”€â”€ layout.tsx              # Root layout
â”œâ”€â”€ page.tsx                # Landing page
â”œâ”€â”€ loading.tsx             # Global loading
â”œâ”€â”€ error.tsx               # Global error
â””â”€â”€ not-found.tsx           # 404 page
```

**Reglas:**
- âœ… Solo imports de features: `import { SalesPage } from '@/features/sales'`
- âœ… MÃ¡ximo 15 lÃ­neas por page.tsx
- âœ… Solo metadata, params extraction, y return del componente
- âŒ NO useState, useEffect, o lÃ³gica de negocio
- âŒ NO llamadas directas a APIs

### 2. **FEATURES** (`src/features/`)
**PropÃ³sito:** OrganizaciÃ³n por dominio de negocio. Auto-contenidos.

**Estructura por feature:**
```
features/[feature-name]/
â”œâ”€â”€ components/             # UI components del feature
â”œâ”€â”€ hooks/                  # Custom hooks
â”œâ”€â”€ services/               # API services (cliente)
â”œâ”€â”€ actions/                # Server actions (servidor)
â”œâ”€â”€ types/                  # TypeScript types
â”œâ”€â”€ constants/              # Constantes del feature
```

**Reglas:**
- âœ… Auto-contenido: todo lo del dominio junto
- âœ… Reutilizable en mÃºltiples pÃ¡ginas
- âŒ NO dependencias circulares entre features
- âŒ NO imports directos `../other-feature/`

### 3. **SHARED** (`src/features/shared/`)
**PropÃ³sito:** CÃ³digo compartido entre mÃºltiples features.

**Estructura:**
```
features/shared/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ layout/             # Header, Sidebar, Footer
â”‚   â”œâ”€â”€ business/           # UserAvatar, StatusBadge, etc.
â”‚   â””â”€â”€ forms/              # Form wrappers
â”œâ”€â”€ hooks/                  # useApi, usePagination, etc.
â”œâ”€â”€ services/               # api.ts, notifications.ts
â”œâ”€â”€ utils/                  # format.ts, validation.ts
â”œâ”€â”€ types/                  # common.types.ts, api.types.ts
â””â”€â”€ constants/              # Global constants
```

### 4. **COMPONENTS** (`src/components/`)
**PropÃ³sito:** shadcn/ui components y componentes personalizados.

**Estructura:**
```
components/
â”œâ”€â”€ ui/                     # shadcn components (no modificar)
â”‚   â”œâ”€â”€ button.tsx          # npx shadcn-ui@latest add button
â”‚   â”œâ”€â”€ input.tsx
â”‚   â””â”€â”€ ...
â””â”€â”€ custom/                 # Componentes personalizados complejos
    â”œâ”€â”€ data-table.tsx
    â”œâ”€â”€ file-upload.tsx
    â””â”€â”€ ...
```

---

## ğŸ”§ REGLAS DE ACTIONS vs SERVICES

### **ACTIONS** (`features/*/actions/`)
**CuÃ¡ndo usar:** Server Actions con `'use server'` que llaman a APIs externas/backend

**CaracterÃ­sticas:**
- âœ… Formularios simples con progressive enhancement
- âœ… Llamadas a tu backend API usando wrapper centralizado
- âœ… Validaciones server-side obligatorias (nunca confiar en cliente)
- âœ… TransformaciÃ³n de respuestas backend â†’ formato componente
- âœ… Un archivo por action compleja
- âœ… Reciben FormData (estÃ¡ndar Next.js) pero pueden tener wrappers directos

**Estructura:**
```typescript
'use server'
import { api } from '@/features/shared/services/api'

export async function createSaleAction(formData: FormData) {
  // 1. Extraer datos de FormData
  const title = formData.get('title') as string
  
  // 2. ValidaciÃ³n server-side OBLIGATORIA
  if (!title) return { success: false, error: 'Title required' }
  
  // 3. Llamada a backend usando wrapper
  const response = await api.post('/sales', { title })
  
  // 4. Transformar respuesta para componente
  return { success: true, message: response.message }
}

// Wrapper opcional para uso directo
export async function createSale(title: string) {
  const formData = new FormData()
  formData.append('title', title)
  return createSaleAction(formData)
}
```

### **SERVICES** (`features/*/services/`)
**CuÃ¡ndo usar:** API calls desde cliente para interactividad compleja

**CaracterÃ­sticas:**
- âœ… Llamadas HTTP desde client components
- âœ… Interactividad compleja con estados
- âœ… Refetch dinÃ¡mico y cache management
- âœ… MÃºltiples services en un archivo
- âœ… Usado en hooks para manejo de estado
- âœ… Usa el mismo wrapper de API

**Estructura:**
```typescript
import { api } from '@/features/shared/services/api'

export class SalesService {
  static async getSales(): Promise<Sale[]> {
    return api.get<Sale[]>('/sales')
  }
  
  static async updateSale(id: string, data: UpdateSaleData): Promise<Sale> {
    return api.put<Sale>(`/sales/${id}`, data)
  }
}
```

---

## ğŸ“¦ REGLAS DE IMPORTS Y EXPORTS

### **Path Mapping:**
```json
{
  "paths": {
    "@/*": ["./src/*"],
    "@/features/*": ["./src/features/*"],
    "@/shared/*": ["./src/features/shared/*"],
    "@/components/*": ["./src/components/*"]
  }
}
```


### **Imports Correctos:**
```typescript
// âœ… CORRECTO
import { SalesPage, useSales } from '@/features/sales'
import { Button } from '@/components/ui/button'
import { UserAvatar } from '@/shared/components/business'

// âŒ INCORRECTO
import { SalesPage } from '../../../features/sales/components/SalesPage'
import { useSales } from '@/features/sales/hooks/useSales'
```

---

## ğŸ“‹ REGLAS DE NOMENCLATURA

### **Carpetas:**
- kebab-case: `user-management`, `payment-methods`
- Singular para types: `type/user.types.ts`
- Plural para data: `components/`, `services/`

### **Archivos:**
- Components: PascalCase: `SalesPage.tsx`
- Hooks: camelCase: `useSales.ts`
- Services: camelCase: `salesApi.ts`
- Actions: kebab-case: `create-sale.ts`
- Types: kebab-case: `sale.types.ts`
- Constants: kebab-case: `sales.constants.ts`

### **Exports:**
- Components: Named exports 
- Functions: Named exports
- Constants: Named exports como const assertions

---

## ğŸ¯ PATRONES DE CÃ“DIGO

### **Page.tsx Pattern:**
```typescript
// app/sales/page.tsx
import { SalesPage } from '@/features/sales'
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Sales | CRM'
}

export default function Page() {
  return <SalesPage />
}
```

### **Component Pattern:**
```typescript
// features/sales/components/SalesPage.tsx
'use client'
import { Button } from '@/components/ui/button'
import { useSales } from '../hooks/useSales'

export const SalesPage = () => {
  const { sales, loading } = useSales()
  // LÃ³gica del componente aquÃ­
  return <div>...</div>
}
```

### **Hook Pattern:**
```typescript
// features/sales/hooks/useSales.ts
import { useState, useEffect } from 'react'
import { SalesService } from '@/sales/services/salesApi'

export const useSales = (filters?: SaleFilters) => {
  const [sales, setSales] = useState<Sale[]>([])
  const [loading, setLoading] = useState(false)
  
  // LÃ³gica del hook
  return { sales, loading, refetch }
}
```

### **Types Pattern:**
```typescript
// features/sales/types/sale.types.ts
export interface Sale {
  id: string
  amount: number
  status: SaleStatus
}

export type SaleStatus = 'pending' | 'approved' | 'rejected'

export interface CreateSaleData {
  amount: number
  customerId: string
}
```

---

## âœ… CHECKLIST DE VALIDACIÃ“N

### **Antes de crear un componente:**
- [ ] Â¿Es especÃ­fico de un feature? â†’ `features/[feature]/components/`
- [ ] Â¿Es compartido entre features? â†’ `features/shared/components/`
- [ ] Â¿Es un UI primitive? â†’ `@/ui/` (shadcn)
- [ ] Â¿Es complejo y personalizado? â†’ `@/ui/custom/`

### **Antes de crear una funciÃ³n:**
- [ ] Â¿Es server-side con `'use server'`? â†’ `actions/`
- [ ] Â¿Es client-side API call? â†’ `services/`
- [ ] Â¿Maneja estado React? â†’ `hooks/`
- [ ] Â¿Es utilidad pura? â†’ `utils/`

### **Antes de crear un type:**
- [ ] Â¿Es especÃ­fico del feature? â†’ `features/[feature]/types/`
- [ ] Â¿Se usa en 2+ features? â†’ `features/shared/types/`
- [ ] Â¿Es declaraciÃ³n global? â†’ `src/types/`

---

## ğŸš¨ ERRORES COMUNES A EVITAR

### **âŒ NO hacer:**
```typescript
// Server Action sin validaciÃ³n server-side
export async function createSale(formData: FormData) {
  'use server'
  // âŒ NUNCA confÃ­es solo en validaciÃ³n cliente
  const data = formData.get('data') as string
  await api.post('/sales', data) // Sin validar
}

// Imports relativos largos en lugar de path mapping
import { Sale } from '../../../types/sale' // âŒ
import { LoginModal } from '../../../../auth/components/LoginModal' // âŒ

// Dependencia circular entre features
// features/sales imports features/users
// features/users imports features/sales // âŒ

// Usar axios en Server Components
import axios from 'axios' // âŒ No aprovecha optimizaciones Next.js
export default async function Page() {
  const data = await axios.get('/api/data') // âŒ
}

// Llamar API directamente sin wrapper
const response = await fetch('/api/data') // âŒ Sin error handling estandarizado
```

### **âœ… Hacer:**
```typescript
// Server Action con validaciÃ³n completa
'use server'
export async function createSaleAction(formData: FormData) {
  const title = formData.get('title') as string
  
  // âœ… ValidaciÃ³n server-side obligatoria
  if (!title?.trim()) return { success: false, error: 'Title required' }
  
  try {
    const response = await api.post<Sale>('/sales', { title })
    return { success: true, message: response.message }
  } catch (error) {
    // âœ… Error handling estandarizado
    if (error instanceof ApiError) {
      return { success: false, error: error.message, errors: error.errors }
    }
    return { success: false, error: 'Error interno' }
  }
}

// Imports limpios y directos
import { Sale } from '@/sales/types/sale.types' // âœ…
import { LoginModal } from '@/auth/components/LoginModal' // âœ…
import { api } from '@/shared/services/api' // âœ…

// fetch() en Server Components
export default async function Page() {
  const data = await serverApi.revalidate<Data>('/data', 3600) // âœ…
  return <Component data={data} />
}

// Usar wrapper centralizado
const sales = await api.get<Sale[]>('/sales') // âœ… Error handling automÃ¡tico
```

---

## ğŸ“– EJEMPLOS DE FEATURES COMPLETOS

### **Feature pequeÃ±o (auth):**
```
features/auth/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ LoginForm.tsx
â”‚   â”œâ”€â”€ LoginPage.tsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.ts
â”œâ”€â”€ services/
â”‚   â””â”€â”€ authApi.ts
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ login.ts
â”œâ”€â”€ types/
â”‚   â””â”€â”€ auth.types.ts
```

### **Feature complejo (payments):**
```
features/payments/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ PaymentsPage.tsx
â”‚   â”œâ”€â”€ PaymentDetailsPage.tsx
â”‚   â”œâ”€â”€ AdminPaymentsPage.tsx
â”‚   â”œâ”€â”€ PaymentsList.tsx
â”‚   â”œâ”€â”€ PaymentCard.tsx
â”‚   â”œâ”€â”€ PaymentForm.tsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ usePayments.ts
â”‚   â”œâ”€â”€ usePayment.ts
â”‚   â””â”€â”€ usePaymentActions.ts
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ paymentsApi.ts
â”‚   â””â”€â”€ stripeService.ts
â”œâ”€â”€ actions/
â”‚   â”œâ”€â”€ create-payment.ts
â”‚   â””â”€â”€ approve-payment.ts
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ payment.types.ts
â”‚   â””â”€â”€ payment-api.types.ts
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ payments.constants.ts
```

---

## ğŸ¯ COMANDOS ÃšTILES

### **Crear feature nuevo:**
```bash
mkdir -p src/features/[feature-name]/{components,hooks,services,actions,types,constants}
```

### **Instalar componente shadcn:**
```bash
bunx shadcn-ui@latest add button
bunx shadcn-ui@latest add input
bunx shadcn-ui@latest add table
```

### **Comandos de desarrollo:**
```bash
# Instalar dependencias
bun install

# Desarrollo
bun dev

# Build
bun run build

# Lint
bun run lint

# Test
bun test
```

### **Estructura de import tÃ­pica:**
```typescript
// External libraries
import { useState } from 'react'
import { NextResponse } from 'next/server'

// shadcn components  
import { Button } from '@/ui/button'

// Shared components
import { UserAvatar } from '@/shared/components/business/UserAvatar'

// Feature imports
import { useSales } from '@/sales/hooks/useSales'
import { SalesService } from '@/sales/services/salesApi'
import type { Sale } from '@/sales/types/sale.types'

// Local imports (mismo feature)
import { SaleCard } from './SaleCard'
```

---

## ğŸ”„ PRINCIPIOS FUNDAMENTALES

### **1. Server Actions vs Services:**
- **Server Actions** â†’ Formularios, mutaciones, llamadas a backend API
- **Services** â†’ Interactividad cliente, estados complejos, refetch dinÃ¡mico
- **Ambos usan el mismo wrapper de API centralizado**

### **2. ValidaciÃ³n obligatoria:**
- **Cliente** â†’ UX inmediata (mostrar errores al usuario)
- **Server Actions** â†’ Seguridad (validaciÃ³n server-side OBLIGATORIA)
- **Backend** â†’ LÃ³gica de negocio (validaciones de dominio)

### **3. Imports y estructura:**
- **Imports directos** â†’ Mejor performance, tree shaking
- **Features auto-contenidos** â†’ Todo lo del dominio junto
- **API wrapper centralizado** â†’ Consistencia en todas las llamadas

### **4. SeparaciÃ³n de responsabilidades:**
- **app/** â†’ Solo routing, layouts, metadata (mÃ¡ximo 15 lÃ­neas por page)
- **features/** â†’ LÃ³gica de negocio organizada por dominio
- **lib/** â†’ Configuraciones globales (env, db, auth)
- **components/** â†’ shadcn/ui components y customs complejos

---

**Toda implementaciÃ³n debe seguir estos principios y patrones establecidos.**